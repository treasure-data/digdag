plugins {
    id 'com.github.johnrengelman.shadow' version '2.0.3'
    id 'com.jfrog.bintray' version '1.8.1'
    id 'com.github.kt3k.coveralls' version '2.6.3'
    id 'com.github.spotbugs' version '1.6.2'
    id 'net.ltgt.apt-idea' version '0.19'
}

apply plugin: 'com.github.johnrengelman.shadow'
apply plugin: 'idea'
apply plugin: 'maven'

allprojects {
    group = 'io.digdag'
    version = '0.10.0-SNAPSHOT'

    ext {
        isSnapshotRelease = version.endsWith('-SNAPSHOT')
        if (project.hasProperty("snapshotVersion")) {
            if (isSnapshotRelease) {
                project.version = project.version.replaceAll(/-SNAPSHOT$/, "-${project.snapshotVersion}")
            }
            else {
                throw new GradleException("-PsnapshotVersion is set but current version is not -SNAPSHOT")
            }
        }
    }

    apply plugin: 'idea'
    apply plugin: 'java'
    apply plugin: 'jacoco'
    apply plugin: 'com.jfrog.bintray'
    apply plugin: 'maven-publish'
    apply plugin: 'net.ltgt.apt-idea'

    repositories {
        mavenCentral()
        jcenter()
        maven {
            url  "http://dl.bintray.com/digdag/maven"
        }
        maven {
            url  "http://dl.bintray.com/digdag/maven-snapshots"
        }
    }

    jacoco {
        toolVersion = '0.8.3'
    }

    bintray {
        user = System.getenv('BINTRAY_USER')
        key = System.getenv('BINTRAY_KEY')

        publications = ['mavenJava']

        filesSpec {
            // include digdag-<version>.jar built by 'cli' task
            from "pkg/digdag-${project.version}.jar"
            into "."
        }

        dryRun = false
        publish = true

        pkg {
            userOrg = 'digdag'
            if (project.ext.isSnapshotRelease) {
                repo = 'maven-snapshots'
                name = 'digdag-snapshots'
            }
            else {
                repo = 'maven'
                name = 'digdag'
            }
            licenses = ['Apache-2.0']
            publicDownloadNumbers = true

            version {
                name = project.version
                released = new Date().format("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
                vcsTag = "v${project.version}"
            }
        }
    }
}

subprojects {
    apply plugin: 'maven'
    apply plugin: 'com.github.spotbugs'

    sourceCompatibility = 1.8
    targetCompatibility = 1.8

    compileJava.options.encoding = 'UTF-8'
    compileTestJava.options.encoding = 'UTF-8'

    dependencies {
        compile 'org.slf4j:slf4j-api:1.7.21'

        compileOnly "org.immutables:value:2.3.9:annotations"
        testCompileOnly "org.immutables:value:2.3.9:annotations"
        annotationProcessor "org.immutables:value:2.3.9"
        testAnnotationProcessor "org.immutables:value:2.3.9"

        testCompile 'junit:junit:4.12'
        testCompile 'org.hamcrest:hamcrest-library:1.3'
        testCompile 'org.mockito:mockito-core:1.10.19'
        testCompile 'pl.pragmatists:JUnitParams:1.0.5'
    }

    ext {
        jacksonVersion = "2.9.9"
        jacksonDatabindVersion = "2.9.9"
        awsJavaSdkVersion = "1.11.545"
        guavaVersion = "19.0"
    }

    tasks.withType(JavaCompile) {
        options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
    }

    spotbugs {
        toolVersion = '3.1.5'
        effort = 'max'
        reportLevel = 'high'
        ignoreFailures = true
        excludeFilter = file("${rootProject.projectDir}/config/findbugs-exclude.xml")
    }

    tasks.withType(com.github.spotbugs.SpotBugsTask) {
        reports {
            xml.enabled = false
            html.enabled = true
        }
    }

    jacocoTestReport {
        // exclude classes generated by Immutables
        afterEvaluate {
            classDirectories = files(classDirectories.files.collect {
                fileTree(dir: it, exclude: ['**/Immutable*'])
            })
        }
    }

    // "./gradlew check" runs jacocoTestReport
    check.dependsOn('jacocoTestReport')

    test {
        testLogging {
            info.events = ["started", "passed", "skipped", "failed", "standardOut", "standardError"]
        }

        // Shard test classes over CI workers
        if (System.env.CI_NODE_INDEX) {
            def n = System.env.CI_NODE_TOTAL as Integer
            def i = System.env.CI_NODE_INDEX as Integer
            include {
                // Recurse into all packages
                if (it.file.isDirectory()) {
                    return true
                }

                // Include test class based on worker index
                def included = Math.abs(it.file.hashCode()) % n == i
                if (System.env.CI_DEBUG?.toBoolean()) {
                    logger.info("test '" + it.file + '" included: ' + included)
                }
                return included
            }
        }

        doFirst {
            // used by TemporaryDigdagServer
            if (jacoco.enabled) {
                def workingDir = getWorkingDir()
                setWorkingDir('/')  // let jacoco.getAsJvmArg generate absolute path
                environment "JACOCO_JVM_ARG", jacoco.getAsJvmArg()
                setWorkingDir(workingDir)
            }
        }
    }

    javadoc {
        options {
            locale = 'en_US'
            encoding = 'UTF-8'
        }
    }

    task testsJar(type: Jar) {
        classifier = 'tests'
        from sourceSets.test.output
    }
    task sourcesJar(type: Jar) {
        classifier = 'sources'
        from sourceSets.main.allSource
    }
    task javadocJar(type: Jar) {
        classifier = 'javadoc'
        from javadoc
    }

    task deps(type: DependencyReportTask) {
    }

    configurations {
        testArtifacts.extendsFrom testRuntime
    }

    artifacts {
        testArtifacts testsJar
    }

    def generateDependency = { String scope, xml, dep ->
        def dependenciesNode = xml.dependencies[0] ?: xml.appendNode('dependencies')
        def dependencyNode = dependenciesNode.appendNode('dependency')
        dependencyNode.appendNode('groupId', dep.group)
        dependencyNode.appendNode('artifactId', dep.name)
        dependencyNode.appendNode('version', dep.version)
        if (scope != 'compile') {
            dependencyNode.appendNode('scope', scope)
        }
        if (dep.targetConfiguration == 'testArtifacts') {
            dependencyNode.appendNode('classifier', 'tests')
        }
        dep.excludeRules.each { ExcludeRule rule ->
            // apply exclusions
            def xmlExclusions = dependencyNode.exclusions[0] ?: dependencyNode.appendNode('exclusions')
            def xmlExclusion = xmlExclusions.appendNode('exclusion')
            xmlExclusion.appendNode('groupId', rule.group)
            xmlExclusion.appendNode('artifactId', rule.module == null ? '*' : rule.module)
        }
    }

    def pomXmlModifier = {
        def xml = asNode()

        // gradle somehow uses 'runtime' as the default scope but 'compile' is desired.
        // gradle also makes transitive dependencies flat somehow but it's not desired.
        // here recreates dependencies section.
        xml.remove(xml.dependencies)

        // configuration compile
        configurations.compile.allDependencies.each(generateDependency.curry('compile', xml))
        configurations.runtime.dependencies.each(generateDependency.curry('runtime', xml))
        configurations.testCompile.dependencies.each(generateDependency.curry('test', xml))
        configurations.testRuntime.dependencies.each(generateDependency.curry('test', xml))
        configurations.annotationProcessor.dependencies.each(generateDependency.curry('provided', xml))
    }

    // Generate maven manifests for sub-modules
    task pom {
        doLast {
            pom {
                project {
                    parent {
                        groupId project.group
                        artifactId 'digdag'
                        version project.version
                    }
                }
            }
            .withXml(pomXmlModifier)
            .writeTo("${delegate.project.projectDir}/pom.xml")
        }
    }

    publishing {
        publications {
            if (![project(":digdag-docs")].contains(project)) {
                mavenJava(MavenPublication) {
                    from components.java
                    afterEvaluate {
                        artifact testsJar
                        artifact sourcesJar
                        artifact javadocJar

                        pom.withXml(pomXmlModifier)
                    }
                }
            }
        }
    }
}

jacocoTestReport {
    dependsOn = subprojects.test
    sourceDirectories = files(subprojects.sourceSets.main.allSource.srcDirs)
    classDirectories =  files(subprojects.sourceSets.main.output)
    executionData = files(subprojects.jacocoTestReport.executionData)
    reports {
        xml.enabled = true
        html.enabled = true
    }
    onlyIf = { true }
    doFirst {
        executionData = files(executionData.findAll { it.exists() })
    }
    afterEvaluate {
        classDirectories = files(classDirectories.files.collect {
            fileTree(dir: it, exclude: ['**/Immutable*'])
        })
    }
}
check.dependsOn('jacocoTestReport')

coveralls {
    sourceDirs += jacocoTestReport.sourceDirectories.toList()
}

wrapper {
    // Find the latest version at https://gradle.org/releases/
    gradleVersion = '4.8'
}

project(':digdag-ui') {
    task buildUi {
        inputs.files fileTree(dir: ".", include: ["*.js", "*.jsx", "config/*"])
        outputs.dir "public"

        doFirst {
            exec {
                // npm ci requires npm version 5.7 or more.
                commandLine System.env.NPM ?: "npm", "ci"
            }
            exec {
                commandLine System.env.NPM ?: "npm", "run", "build"
                environment "SHA", "assets"
            }
        }
    }

    // include public/* in the jar file
    processResources {
        from '.'
        include 'public/**/*'
    }
    processResources.dependsOn('buildUi')
}

project(':digdag-cli') {
    apply plugin: 'com.github.johnrengelman.shadow'

    // Include digdag-ui in the shadow jar which are not in the dependencies
    // of digdag-cli but should be included.
    configurations {
        shadow {
            extendsFrom runtime
        }
    }

    if (!project.hasProperty("withoutUi")) {
        dependencies {
            shadow project(':digdag-ui')
        }
        shadowJar.dependsOn(project(':digdag-ui').jar)
    }

    shadowJar {
        configurations = [project.configurations.shadow]

        manifest {
            attributes 'Implementation-Title': project.name,
                       'Implementation-Version': project.version,
                       'Implementation-Vendor-Id': project.group,
                       'Specification-Title': project.name,
                       'Specification-Version': project.version,
                       'Main-Class': 'io.digdag.cli.Main'
        }

        mergeServiceFiles {
            // this block is necessary to merge META-INF/services/* files.
            // undertow is using ServiceLoader to find ExchangeAttributeBuilder
            // which is used by access logger.
        }

        // force org.weakref.jmx to use unshaded guava to keep binary size small
        exclude 'org/weakref/jmx/internal/guava/**/*'
        relocate 'org.weakref.jmx.internal.guava', 'com.google.common'
    }

    task classpath(type: Copy, dependsOn: ['jar']) {
        File dest = file("${rootProject.projectDir}/classpath")
        doFirst { dest.deleteDir() }
        from configurations.shadow + files("${project.libsDir}/${project.name}-${project.version}.jar")
        into dest
    }
}

def cliBuildFile = file("pkg/digdag-${project.version}.jar")

task cli(dependsOn: ':digdag-cli:shadowJar') {
    doLast {
        file('pkg').mkdirs()
        cliBuildFile.write("")
        cliBuildFile.append(file("digdag-cli/src/main/sh/selfrun.sh").readBytes())
        cliBuildFile.append(file("digdag-cli/build/libs/digdag-cli-${project.version}-all.jar").readBytes())
        cliBuildFile.setExecutable(true)
    }
}

bintrayUpload.dependsOn('cli')

task classpath(dependsOn: [':digdag-cli:classpath']){
    doLast {
    }
}

clean {
    delete 'classpath'
    delete 'pkg'
    delete 'digdag-ui/public'
}

task release() {
    dependsOn subprojects.publish
    dependsOn bintrayUpload
    doLast {
        println "Released ${project.version}."
    }
}
check.dependsOn('releaseCheck')

task setVersion {
    doLast {
        if (!project.hasProperty("to")) {
            throw new GradleException("Usage: ./gradlew setVersion -Pto=VERSION")
        }

        File gradle_ver = file('build.gradle')
        gradle_ver.write(gradle_ver.getText().replaceFirst("version = '(\\d+)(\\.\\d+){2}(-[\\d\\w]+)?'", "version = '${to}'"))

        List<String> files = [
            'digdag-client/src/main/resources/io/digdag/client/version.txt',
            'digdag-cli/src/main/java/io/digdag/cli/Main.java',
            'digdag-cli/src/main/java/io/digdag/cli/SelfUpdate.java',
        ]

        files.each() { path ->
            File doc = file(path)
            doc.write(doc.getText().replaceAll("0\\.[1-9][0-9]*\\.(\\d+)(-[\\d\\w]+)?", "${to}"))
        }

        if (!to.endsWith('-SNAPSHOT')) {
            // update docs
            [
                'digdag-docs/src/command_reference.rst',
            ].each() { path ->
                File doc = file(path)
                doc.write(doc.getText().replaceAll("0\\.[1-9][0-9]*\\.(\\d+)(-[\\d\\w]+)?", "${to}"))
            }

            // releases.rst
            File releases = file("digdag-docs/src/releases.rst")
            releases.write(releases.getText().replaceAll("# add new version here", "# add new version here\n    releases/release-${to}"))

            // release-<versionr>.rst
            String notePath = "digdag-docs/src/releases/release-${to}.rst"
            file(notePath).append(
                    "Release ${to}\n" +
                    "==============\n" +
                    "\n" +
                    "...\n" +
                    "\n" +
                    "Release Date\n" +
                    "------------\n" +
                    "${new Date().format('yyyy-MM-dd')}\n" +
                    "\n" +
                    "Contributors\n" +
                    "------------\n")
            ["bash", "-c", "git shortlog -s \$(git tag --sort=-creatordate | head -n 1)..HEAD | awk '{\$1=\"\";print \"*\" \$0}' >> ${notePath}"].execute().waitFor()
            "git add ${notePath}".execute().waitFor()
        }
    }
}

task releaseCheck {
    doLast {
        if (project.ext.isSnapshotRelease) {
            println "Releasing a SNAPSHOT version."
        }
        else {
            if (!file("digdag-client/src/main/resources/io/digdag/client/version.txt").getText().contains("${project.version}")) {
                throw new GradleException("digdag-client/src/main/resources/io/digdag/client/version.txt doesn't include ${project.version}")
            }
            if (!file("digdag-docs/src/releases/release-${project.version}.rst").getText().contains("${project.version}")) {
                throw new GradleException("Release note for ${project.version} doesn't exist")
            }
            if (!file("digdag-docs/src/releases.rst").getText().contains("release-${project.version}")) {
                throw new GradleException("digdag-docs/src/releases.rst doesn't include release-${project.version}")
            }
            String date = new Date().format("yyyy-MM-dd")
            if (!file("digdag-docs/src/releases/release-${project.version}.rst").getText().contains(date)) {
                throw new GradleException("digdag-docs/src/releases/release-${project.version}.rst doesn't include today's release date")
            }
            // TODO check git-ls-files includes release-<version>.rst file
            println "Ready. Run 'release' task."
        }
    }
}

// Utility task to release a snapshot version with a fixed version number.
// Bintray doesn't allow releasing -SNAPSHOT version.
task releaseSnapshot(type: Exec) {
    commandLine "bash", "-c", "./gradlew -PsnapshotVersion=\$(TZ=UTC git log -n 1 --pretty='format:%ad-%H' --date 'format-local:%Y%m%dT%H%M%S') release"
}

// Generate parent maven manifest
task pom {
    doLast {
        pom {
            project {
                packaging 'pom'
                properties {
                    project {
                        build {
                            sourceEncoding 'UTF-8'
                        }
                    }
                }
                repositories {
                    repository {
                        id 'jcenter'
                        url 'http://jcenter.bintray.com'
                        releases {
                            enabled 'true'
                        }
                    }
                }
                modules {
                    subprojects.each {
                        module it.name
                    }
                }
            }
        }.withXml {
            // XXX (dano): http://stackoverflow.com/a/27978130
            def build = asNode().appendNode('build', '')
            def plugins = build.appendNode('plugins', '')

            def compiler = plugins.appendNode('plugin', '')
            compiler.appendNode('groupId', 'org.apache.maven.plugins')
            compiler.appendNode('artifactId', 'maven-compiler-plugin')
            compiler.appendNode('version', '3.5.1')
            def compiler_configuration = compiler.appendNode('configuration', '')
            compiler_configuration.appendNode('source', sourceCompatibility)
            compiler_configuration.appendNode('target', targetCompatibility)

            def enforcer = plugins.appendNode('plugin', '')
            enforcer.appendNode('groupId', 'org.apache.maven.plugins')
            enforcer.appendNode('artifactId', 'maven-enforcer-plugin')
            enforcer.appendNode('version', '1.4.1')
            def enforcer_executions = enforcer.appendNode('executions', '')
            def enforcer_execution = enforcer_executions.appendNode('execution', '')
            enforcer_execution.appendNode('id', 'enforce')
            def enforcer_goals = enforcer_execution.appendNode('goals', '')
            enforcer_goals.appendNode('goal', 'enforce')

            def enforcer_execution_configuration = enforcer_execution.appendNode('configuration', '')
            def enforcer_rules = enforcer_execution_configuration.appendNode('rules', '')
            enforcer_rules.appendNode('requireUpperBoundDeps', '')

            def jar = plugins.appendNode('plugin', '')
            jar.appendNode('groupId', 'org.apache.maven.plugins')
            jar.appendNode('artifactId', 'maven-jar-plugin')
            jar.appendNode('version', '3.0.2')
            def jar_executions = jar.appendNode('executions', '')
            def jar_execution = jar_executions.appendNode('execution', '')
            def jar_execution_goals = jar_execution.appendNode('goals', '')
            jar_execution_goals.appendNode('goal', 'test-jar')
        }.writeTo("pom.xml")
    }
}

task runServer(type: JavaExec) {
    classpath = project(":digdag-cli").sourceSets.main.runtimeClasspath
    main = 'io.digdag.cli.Main'
    args 'server',
            '-c', '/dev/null',
            '-m',
            '-H', 'Access-Control-Allow-Origin=http://localhost:8080',
            '-H', 'Access-Control-Allow-Headers=origin, content-type, accept, authorization',
            '-H', 'Access-Control-Allow-Credentials=true',
            '-H', 'Access-Control-Allow-Methods=GET, POST, PUT, DELETE, OPTIONS, HEAD',
            '-H', 'Access-Control-Max-Age=1209600'
}
